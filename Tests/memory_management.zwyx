#Test for memory management


_import:"utilities_lib"

BoxedInt~{el~int}

memCpy~{from~bytes to~bytes ;~{
        fromPtr~@CIter:from
        toPtr~@CIter:to
        num~int:from.count
        {num > 0}?*{
                toPtr.el:fromPtr.el
                fromPtr:{fromPtr+1}
                toPtr:{toPtr+1}
                num:{num-1}
        }
}}

MemArena~{
        data~bytes
        alloc~{numBytes~int ;~{
                {numBytes % 8}?{
                        numBytes:{numBytes / 8 * 8 + 8}
                }
                chunkPtr~@BoxedInt:data
                chunkSize~int
                {chunkPtr.el & 0x8000}?{
                        chunkSize:0
                }^{
                        chunkSize:chunkPtr.el
                }
                {{chunkPtr.el & 0x8000} | {chunkSize < numBytes}}?*{
                        chunkPtr:{chunkPtr+8+{chunkPtr.el & 0x7FFF}}
                        {chunkPtr.el & 0x8000}?{
                                chunkSize:0
                        }^{
                                chunkSize:chunkPtr.el
                        }
                }
                {chunkSize > numBytes}?{
                        nextChunkPtr~@BoxedInt:{chunkPtr + 8 + numBytes}
                        nextChunkPtr.el:{chunkSize - numBytes - 8}
                }
                chunkPtr.el:{numBytes | 0x8000}
                chunkPtr+8
        }}
        free~{chunk~bytes ;~{
                chunkPtr~@BoxedInt:{chunk-8}
                chunkPtr.el:{chunkPtr.el & 0x7FFF}
        }}
        set~{b~bytes ;~{
                data:b
                chunkPtr~@BoxedInt:data
                chunkPtr.el:{data.count - 8}
                
                chunkPtr:{chunkPtr + 8}
                for.{i:8 step:8 end:data.count do:@{
                        chunkPtr.el:0
                        chunkPtr:{chunkPtr+8}
                } ; }
        }}
}

DynString~{
        b~bytes
        capacity~int:0
        memHandler~@MemArena
        write~{
		~WriteNF
		fn:@{
		        countin~int:data.count
		        {{b.count+countin} > capacity}?{
		                free_b~int:1
		                {capacity = 0}?{
		                        capacity:16
		                        free_b:0
		                        
		                        b.count:0
		                }
		                {{b.count+countin} > capacity}?*{
		                        capacity:{capacity*2}
		                }
		                new_b~bytes:memHandler.alloc:capacity
		                new_b.count:b.count
		                memCpy.{to:new_b from:b ;}
		                {free_b}?{
		                        memHandler.free:b
		                }
		                b:new_b
		        }
			memCpy.{to:{b+b.count} from:data ;}
			b.count:{b.count+countin}
		}
	}
	clear~{;~{ b.count:0 }}
	destroy~{;~{
	       clear
	       capacity:0
	       
	       memHandler.free:b
	}}
}

buff~bytes.400

;~{
        mem~MemArena.{set:@buff}
        
        str1~DynString.{memHandler:@mem write:"Hello, World!"}
        str2~DynString.{memHandler:@mem write:"Chunk of some data!"}
        print.line:str1
        print.line:str2
        
        str1.write:" Yes, we meet again!"
        str2.write:" Bigger chunk of some data!"
        print.line:str1
        print.line:str2
        
        str1.{destroy write:"Test for finding open chunks."}
        print.line:str1
        
        buffPtr~@BoxedInt:@buff
        for.{end:400 do:@{
                print.{d:{buffPtr.el % 256} s:" "}
                buffPtr:{buffPtr+1}
        } ; }
        print.endl
        
        str1.write:" This will go to the next chunk."
        print.line:str1
        
        buffPtr:@buff
        for.{end:400 do:@{
                print.{d:{buffPtr.el % 256} s:" "}
                buffPtr:{buffPtr+1}
        } ; }
        print.endl
}

