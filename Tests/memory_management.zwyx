#Test for memory management


_import:"utilities_lib"

BoxedInt~{el~int}

MemManagerNF~{
        alloc~{numBytes~int}
        free~{chunk~bytes}
        allocFn~virtual:alloc
        freeFn~virtual:free
}

memCpy~{from~bytes to~bytes ;~{
        fromPtr~@CIter:from
        toPtr~@CIter:to
        num~int:from.count
        {num > 0}?*{
                toPtr.el:fromPtr.el
                fromPtr:{fromPtr+1}
                toPtr:{toPtr+1}
                num:{num-1}
        }
}}

MemArena~{
        ~MemManagerNF
        data~bytes
        firstOpenChunkA~int
        allocFn:@{
                {numBytes % 8}?{
                        numBytes:{numBytes / 8 * 8 + 8}
                }
                chunkSize~int:0
                chunkBytes~bytes:{firstOpenChunkA - 8}
                chunkPtr~@BoxedInt:chunkBytes
                nextChunkPtr~@BoxedInt:chunkPtr
                {{chunkSize < numBytes} & {{chunkPtr.el & 0xFFFF} < 0xFFFF}}?*{
                        {nextChunkPtr.el & 0x8000}?{
                                chunkSize:0
                                chunkPtr:nextChunkPtr
                        }^{
                                {chunkSize > 0}?{
                                        chunkSize:{chunkSize + 8 + nextChunkPtr.el}
                                        chunkPtr.el:chunkSize
                                }^{
                                        chunkPtr:nextChunkPtr
                                        chunkSize:chunkPtr.el
                                }
                        }
                        nextChunkPtr:{nextChunkPtr+8+{nextChunkPtr.el & 0x7FFF}}
                }
                {chunkPtr.el = 0xFFFF}?{0}^{
                        {chunkSize > numBytes}?{
                                nextChunkPtr:{chunkPtr + 8 + numBytes}
                                nextChunkPtr.el:{chunkSize - numBytes - 8}
                        }
                        chunkPtr.el:{numBytes | 0x8000}
                        chunkBytes:chunkPtr
                        {{chunkBytes + 8} = firstOpenChunkA}?{
                                chunkBytes:{nextChunkPtr + 8}
                                firstOpenChunkA:chunkBytes
                        }
                        chunkPtr+8
                }
        }
        freeFn:@{
                chunkPtr~@BoxedInt:{chunk-8}
                chunkPtr.el:{chunkPtr.el & 0x7FFF}
                {chunk < firstOpenChunkA}?{
                        firstOpenChunkA:chunk
                }
        }
        set~{b~bytes ;~{
                data:b
                
                chunkPtr~@BoxedInt:data
                chunkPtr.el:{data.count-16}
                
                chunkPtr:{chunkPtr + 8}
                for.{i:8 step:8 end:{data.count-8} do:@{
                        chunkPtr.el:0
                        chunkPtr:{chunkPtr+8}
                } ; }
                
                chunkPtr.el:0xFFFF
                firstOpenChunkA:{data + 8}
        }}
}

heapHandlerPageTableBuffer~bytes.400

HeapHandlerPageTableEntry~{
        data~bytes
        spaceLeft~int
        firstOpenChunk~int
}

heapHandlerPageTable~MasterList:HeapHandlerPageTableEntry

heapHandlerPageTable.buffer:@heapHandlerPageTableBuffer

HeapHandler~{
        ~MemManagerNF
        
        allocFn:@{
                chunk~bytes
                chunk:0
                
                n~int:0
                {chunk = 0}?*{
                        {heapHandlerPageTable.get:n}.{
                                {spaceLeft > numBytes}?{
                                        MemArena.{
                                                firstOpenChunkA:firstOpenChunk
                                                data:{firstOpenChunk - 8}
                                                chunk:$.alloc:numBytes
                                                firstOpenChunk:firstOpenChunkA
                                        }
                                        spaceLeft:{spaceLeft - 8 - numBytes}
                                }^{data = 0}?{
                                        arenaSize~int:4096
                                        {arenaSize < numBytes + 16}?*{
                                                arenaSize:{arenaSize * 2}
                                        }
                                        data:_heap_map:arenaSize
                                        data.count:arenaSize
                                        spaceLeft:{arenaSize - numBytes - 16}
                                        MemArena.{
                                                set:$.2.data
                                                chunk:$.alloc:numBytes
                                                
                                                firstOpenChunk:firstOpenChunkA
                                        }
                                }
                        }
                        n:{n+1}
                }
                
                chunkPtr~@BoxedInt:{chunk - 8}
                chunkPtr.el:{chunkPtr.el | {n * 0x10000}}
                
                chunk
        }
        freeFn:@{
                chunkPtr~@BoxedInt:{chunk - 8}
                entry~@HeapHandlerPageTableEntry
                entry:@heapHandlerPageTableBuffer
                entry:{entry + {24 * {chunkPtr.el / 0x10000 - 1}}}
                MemArena.{
                        firstOpenChunkA:entry.firstOpenChunk
                        $.free:chunk
                        
                        entry.firstOpenChunk:firstOpenChunkA
                }
                entry.spaceLeft:{entry.spaceLeft + chunkPtr.el + 8}
        }
}

heapHandlerStatic~HeapHandler

DynString~{
        b~bytes
        capacity~int:0
        memHandler~@MemManagerNF:@heapHandlerStatic
        write~{
		~WriteNF
		fn:@{
		        countin~int:data.count
		        failed~int:0
		        
		        {{b.count+countin} > capacity}?{
		                free_b~int:1
		                {capacity = 0}?{
		                        capacity:16
		                        free_b:0
		                        
		                        b.count:0
		                }
		                {{b.count+countin} > capacity}?*{
		                        capacity:{capacity*2}
		                }
		                new_b~bytes:memHandler.alloc:capacity
		                {new_b = 0}?{
		                        failed:1
		                }^{
		                        new_b.count:b.count
		                        memCpy.{to:new_b from:b ;}
		                        {free_b}?{
		                                memHandler.free:b
		                        }
		                        b:new_b
		                }
		        }
		        {failed = 0}?{
			        memCpy.{to:{b+b.count} from:data ;}
			        b.count:{b.count+countin}
			}
		}
	}
	clear~{;~{ b.count:0 }}
	destroy~{;~{
	       clear
	       capacity:0
	       
	       memHandler.free:b
	}}
}

MasterDynList~`_io.return~{
        memHandler~@MemManagerNF:@heapHandlerStatic
        b~bytes
        count~int:0
        capacity~int:0
	memberSize~int:_mem_size_of:_io.0
	emplace~{
		in~_io.0.;
		;~{
			failed~int:0
			{{count+1} > capacity}?{
			        free_b~int:1
		                {capacity = 0}?{
		                        capacity:16
		                        free_b:0
		                }^{
		                        capacity:{capacity*2}
		                }
		                new_b~bytes:memHandler.alloc:{capacity*8}
		                {new_b = 0}?{
		                        failed:1
		                }^{
		                        b.count:{count*8}
		                        memCpy.{to:new_b from:b ;}
		                        {free_b}?{
		                                memHandler.free:b
		                        }
		                        b:new_b
		                }
			}
			{failed = 0}?{
			        newMemberBytes~bytes:memHandler.alloc:memberSize
			        newMember~@_io.0:newMemberBytes
			        {newMember}?{
			                newMember.{in}
			                ptr~@BoxedInt:{b+count*8}
			                ptr.el:newMemberBytes
			                count:{count+1}
			        }
			}
		}
	}
	get~{
	        at~int
	        ;~{
	                ptr~@BoxedInt:{b+at*8}
	                temp~bytes:ptr.el
	                result~@_io.0:temp
	                result
	        }
	}
	each~{
	        f~_io.0.;
	        ;~{
	                ptr~@BoxedInt:b
                        for.{
                                end:count
                                do:@{
                                        temp~bytes:ptr.el
                                        ptr2~@_io.0:temp
                                        
                                        ptr2.{f}
                                        ptr:{ptr+8}
                                } ;
                        }
	        }
	}
}`

Employee~{
        name~String
        age~int
}

;~{
        str1~DynString.{write:"Hello, World!"}
        str2~DynString.{write:"Chunk of some data!"}
        print.line:str1
        print.line:str2
        
        str1.write:" Yes, we meet again!"
        str2.write:" Bigger chunk of some data!"
        print.line:str1
        print.line:str2
        
        str1.{destroy write:"Test for finding open chunks."}
        
        db~MasterDynList:Employee.{emplace.{
                $:@{name:"Spuds Magabbener" age:34} ;
                $:@{name:"Boris Boringen" age:52} ;
        }}
        
        db.each:@{print.{s:name s:", " d:age endl}}
        
        entry~@HeapHandlerPageTableEntry
        entry:@heapHandlerPageTableBuffer
        
        buffPtr~@BoxedInt:entry.data
        for.{end:400 do:@{
                print.{d:{buffPtr.el % 256} s:" "}
                buffPtr:{buffPtr+1}
        } ; }
        
        print.endl
        
        for.{end:200 do:@{str1.write:" Filler!"} ; }
        
        table~MasterList:HeapHandlerPageTableEntry
        table.setBuffer:@heapHandlerPageTableBuffer
        entry:table.get:1
        buffPtr:entry.data
        for.{end:400 do:@{
                print.{d:{buffPtr.el % 256} s:" "}
                buffPtr:{buffPtr+1}
        } ; }
        
        print.endl
}

